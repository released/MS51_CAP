C51 COMPILER V9.55   MAIN                                                                  06/28/2021 10:42:03 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Output\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\main.c LARGE OPTIMIZE(7,SPEED) BROWSE INCDIR(..\..\..\..\Library\Devi
                    -ce\Include;..\..\..\..\Library\StdDriver\inc) DEFINE(FOSC_240000) DEBUG OBJECTEXTEND PRINT(.\LST\main.lst) TABS(2) OBJEC
                    -T(.\Output\main.obj)

line level    source

   1          /*--------------------------------------------------------------------------------------------------------
             --*/
   2          /*                                                                                                        
             - */
   3          /* Copyright(c) 2019 Nuvoton Technology Corp. All rights reserved.                                        
             - */
   4          /*                                                                                                        
             - */
   5          /*--------------------------------------------------------------------------------------------------------
             --*/
   6          
   7          /*********************************************************************************************************
             -**/
   8          /* Website: http://www.nuvoton.com                                                                        
             - */
   9          /*  E-Mail : MicroC-8bit@nuvoton.com                                                                      
             - */
  10          /*  Date   : Jan/21/2019                                                                                  
             - */
  11          /*********************************************************************************************************
             -**/
  12          
  13          /*********************************************************************************************************
             -***/
  14          /*  File Function: MS51 DEMO project                                                                      
             -  */
  15          /*********************************************************************************************************
             -***/
  16          
  17          #include "MS51_16K.h"
  18          
  19          
  20          /*_____ M A C R O S ________________________________________________________*/
  21          
  22          #define ABS(X)                    ((X) > 0 ? (X) : -(X)) 
  23          
  24          #define MAKE12BIT(v1,v2)                ((((uint16_t)(v1))<<4)+(uint16_t)(v2))      //v1,v2 is uint8_t
  25          
  26          #define _debug_log_CAPTURE_           (1)
  27          
  28          /*_____ D E F I N I T I O N S ______________________________________________*/
  29          #define SYS_CLOCK                 (24000000ul)
  30          #define TIMER2_CLOCK              (24000000ul >> 6)
  31          
  32          #define PWM_FREQ                (1000ul)
  33          
  34          #define DUTY_RESOLUTION             (10000ul)
  35          #define DUTY_MAX                (DUTY_RESOLUTION)
  36          #define DUTY_MIN                (1ul)
  37          
  38          /*_____ D E C L A R A T I O N S ____________________________________________*/
  39          volatile uint8_t u8TH0_Tmp = 0;
  40          volatile uint8_t u8TL0_Tmp = 0;
C51 COMPILER V9.55   MAIN                                                                  06/28/2021 10:42:03 PAGE 2   

  41          
  42          uint16_t width0 = 0;
  43          uint16_t width1 = 0;
  44          uint16_t widthTotal = 0;
  45          
  46          //UART 0
  47          bit BIT_TMP;
  48          bit BIT_UART;
  49          bit uart0_receive_flag=0;
  50          unsigned char uart0_receive_data;
  51          
  52          
  53          typedef enum{
  54            flag_START = 0 ,
  55          
  56          
  57            flag_200us ,
  58            flag_1ms ,
  59            flag_5ms ,
  60            flag_10ms , 
  61            flag_DEFAULT  
  62          }Flag_Index;
  63          
  64          volatile uint32_t BitFlag = 0;
  65          #define BitFlag_ON(flag)              (BitFlag|=flag)
  66          #define BitFlag_OFF(flag)             (BitFlag&=~flag)
  67          #define BitFlag_READ(flag)              ((BitFlag&flag)?1:0)
  68          #define ReadBit(bit)                (uint32_t)(1<<bit)
  69          
  70          #define is_flag_set(idx)              (BitFlag_READ(ReadBit(idx)))
  71          #define set_flag(idx,en)              ( (en == 1) ? (BitFlag_ON(ReadBit(idx))) : (BitFlag_OFF(ReadBit(idx))))
  72          
  73          
  74          
  75          /*_____ F U N C T I O N S __________________________________________________*/
  76          
  77          void send_UARTString(uint8_t* Data)
  78          {
  79   1        #if 1
  80   1        uint16_t i = 0;
  81   1      
  82   1        while (Data[i] != '\0')
  83   1        {
  84   2          #if 1
  85   2          SBUF = Data[i++];
  86   2          #else
                  UART_Send_Data(UART0,Data[i++]);    
                  #endif
  89   2        }
  90   1      
  91   1        #endif
  92   1      
  93   1        #if 0
                uint16_t i = 0;
                
                for(i = 0;i< (strlen(Data)) ;i++ )
                {
                  UART_Send_Data(UART0,Data[i]);
                }
                #endif
 101   1      
 102   1        #if 0
C51 COMPILER V9.55   MAIN                                                                  06/28/2021 10:42:03 PAGE 3   

                  while(*Data)  
                  {  
                      UART_Send_Data(UART0, (unsigned char) *Data++);  
                  } 
                #endif
 108   1      }
 109          
 110          void send_UARTASCII(uint16_t Temp)
 111          {
 112   1          uint8_t print_buf[16];
 113   1          uint16_t i = 15, j;
 114   1      
 115   1          *(print_buf + i) = '\0';
 116   1          j = (uint16_t)Temp >> 31;
 117   1          if(j)
 118   1              (uint16_t) Temp = ~(uint16_t)Temp + 1;
 119   1          do
 120   1          {
 121   2              i--;
 122   2              *(print_buf + i) = '0' + (uint16_t)Temp % 10;
 123   2              (uint16_t)Temp = (uint16_t)Temp / 10;
 124   2          }
 125   1          while((uint16_t)Temp != 0);
 126   1          if(j)
 127   1          {
 128   2              i--;
 129   2              *(print_buf + i) = '-';
 130   2          }
 131   1          send_UARTString(print_buf + i);
 132   1      }
 133          
 134          
 135          void capture_application (void)
 136          {
 137   1        uint32_t duty = 0;
 138   1        uint16_t freq = 0;  
 139   1        
 140   1        if((CAPCON0 & SET_BIT0) != 0)
 141   1        {
 142   2          #if 1
 143   2          width0 = (C0H << 8 ) | C0L;
 144   2          #else
                  width0 = C0H;
                  width0 <<= 8;
                  width0 |= C0L;
                  #endif
 149   2        }
 150   1      
 151   1        if((CAPCON0 & SET_BIT1) != 0)
 152   1        {
 153   2          #if 1
 154   2          width1 = (C1H << 8 ) | C1L;
 155   2          #else
                  width1 = C1H;
                  width1 <<= 8;
                  width1 |= C1L;  
                  #endif
 160   2        }
 161   1      
 162   1          clr_CAPCON0_CAPF0;  
 163   1          clr_CAPCON0_CAPF1;  
 164   1      
C51 COMPILER V9.55   MAIN                                                                  06/28/2021 10:42:03 PAGE 4   

 165   1        widthTotal = width0 + width1;
 166   1        freq = (float) (TIMER2_CLOCK)/(widthTotal);
 167   1        
 168   1      //  duty = ((unsigned int)DUTY_RESOLUTION*(((float)width1) / widthTotal));  
 169   1        duty = ((unsigned int)DUTY_RESOLUTION*((float)width1 / widthTotal));
 170   1        
 171   1        #if (_debug_log_CAPTURE_ == 1)  // when width0 = 0 , calculate will fail
 172   1      //  if ((ABS((timer2_clk/freq)-widthTotal)<5) && ((width0 != 0) && (width1 != 0) ) )
 173   1        {
 174   2          send_UARTString("capture_application :"); 
 175   2          send_UARTString(",freq:");
 176   2          send_UARTASCII(freq);
 177   2          send_UARTString(",duty:");
 178   2          send_UARTASCII(duty); 
 179   2          send_UARTString(",H:");
 180   2          send_UARTASCII(width0);
 181   2          send_UARTString(",L:");
 182   2          send_UARTASCII(width1); 
 183   2          
 184   2          send_UARTString(",widthTotal:");
 185   2          send_UARTASCII(widthTotal);   
 186   2          send_UARTString(",temp:");
 187   2          send_UARTASCII(TIMER2_CLOCK/freq);  
 188   2          
 189   2          send_UARTString("\r\n");
 190   2      
 191   2        }
 192   1      
 193   1      
 194   1        #endif    
 195   1      }
 196          
 197          void Timer2_ISR (void) interrupt 5
 198          {
 199   1          _push_(SFRS);
 200   1      
 201   1          clr_T2CON_TF2;  
 202   1      
 203   1          _pop_(SFRS);
 204   1      }
 205          
 206          //P1.2 , PWM0_CH0 , IC0 
 207          void CAP_Init(void)
 208          {
 209   1          P12_QUASI_MODE;
 210   1          P12 = 1;
 211   1      
 212   1          TIMER2_CAP0_Capture_Mode;
 213   1        TIMER2_CAP1_Capture_Mode;
 214   1      
 215   1        TIMER2_DIV_64;
 216   1      
 217   1        IC0_P12_CAP0_RISINGEDGE_CAPTRUE;
 218   1        IC0_P12_CAP1_FALLINGEDGE_CAPTURE;
 219   1      
 220   1      //    set_EIE_ECAP; 
 221   1          set_T2CON_TR2;
 222   1        ENABLE_TIMER2_INTERRUPT;
 223   1      
 224   1      //    ENABLE_GLOBAL_INTERRUPT;  
 225   1      }
 226          
C51 COMPILER V9.55   MAIN                                                                  06/28/2021 10:42:03 PAGE 5   

 227          //(P1.5 , PWM0_CH5) : SHAFT_DRIVER ,  motor PWM control output , 16k freq , duty 50 %
 228          void PWM0_CHx_Init(uint16_t uFrequency,uint16_t d)  // ex : duty 83.5% , d = 8350 , duty 26% , d = 2600
 229          {
 230   1        unsigned long res = 0;
 231   1      
 232   1        P15_PUSHPULL_MODE;      //Add this to enhance MOS output capability
 233   1          PWM5_P15_OUTPUT_ENABLE; 
 234   1       
 235   1          PWM_IMDEPENDENT_MODE;
 236   1          PWM_CLOCK_DIV_64;
 237   1      
 238   1      /*
 239   1        PWM frequency   = Fpwm/((PWMPH,PWMPL)+1) = (24MHz/2)/(PWMPH,PWMPL)+1) = 20KHz
 240   1      */  
 241   1        res = (SYS_CLOCK>>6);
 242   1        res = res/uFrequency;   //value 375 for 16K
 243   1        res = res - 1;
 244   1        
 245   1          PWMPH = HIBYTE(res);
 246   1          PWMPL = LOBYTE(res);
 247   1        
 248   1      //  res = d*(MAKEWORD(PWMPH,PWMPL)+1)/DUTY_RESOLUTION;  
 249   1        res = d*(res+1)/DUTY_RESOLUTION;
 250   1      
 251   1        set_SFRS_SFRPAGE;
 252   1          PWM5H = HIBYTE(res);
 253   1          PWM5L = LOBYTE(res);
 254   1          clr_SFRS_SFRPAGE;
 255   1        
 256   1          set_PWMCON0_LOAD;
 257   1          set_PWMCON0_PWMRUN;   
 258   1      
 259   1      }
 260          
 261          void GPIO_Init(void)
 262          {
 263   1        P17_QUASI_MODE;   
 264   1        P30_PUSHPULL_MODE;  
 265   1      }
 266          
 267          void task_10ms(void)
 268          { 
 269   1      
 270   1        if (is_flag_set(flag_10ms))
 271   1        {
 272   2          set_flag(flag_10ms,Disable);
 273   2          
 274   2          //application
 275   2          P30 = ~P30;
 276   2      
 277   2      //    PWM0_CHx_Init(PWM_FREQ , 850);    //8.5 %
 278   2          PWM0_CHx_Init(PWM_FREQ , 7510);   //75.1 %    
 279   2          
 280   2          capture_application();
 281   2          
 282   2        
 283   2        }
 284   1      }
 285          
 286          void task_5ms(void)
 287          {
 288   1        if (is_flag_set(flag_5ms))
C51 COMPILER V9.55   MAIN                                                                  06/28/2021 10:42:03 PAGE 6   

 289   1        {
 290   2          set_flag(flag_5ms,Disable);
 291   2      
 292   2          //application
 293   2      //    P17 = ~P17;
 294   2      
 295   2      
 296   2        
 297   2        }
 298   1      }
 299          
 300          void task_1ms(void)
 301          {
 302   1        if (is_flag_set(flag_1ms))
 303   1        {
 304   2          set_flag(flag_1ms,Disable);
 305   2      
 306   2          //application
 307   2      //    P17 = ~P17;
 308   2      
 309   2          
 310   2        
 311   2        }
 312   1      }
 313          
 314          void task_200us(void)
 315          {
 316   1        if (is_flag_set(flag_200us))
 317   1        {
 318   2          set_flag(flag_200us,Disable);
 319   2      
 320   2          //application
 321   2      //    P17 = ~P17;
 322   2      
 323   2      
 324   2          
 325   2        }
 326   1      }
 327          
 328          void task_loop(void)
 329          {
 330   1      
 331   1        task_200us();
 332   1        task_1ms();
 333   1        task_5ms();
 334   1        task_10ms();
 335   1      
 336   1      
 337   1      }
 338          
 339          void Timer0_IRQHandler(void)
 340          {
 341   1        /*
 342   1            200us base  
 343   1      
 344   1            1ms = 1000 / 200 = 5
 345   1            5ms = 5000 / 200 = 25
 346   1            10ms = 10000 / 200 = 50
 347   1            
 348   1        */
 349   1      
 350   1        const uint16_t div_1ms = 5; 
C51 COMPILER V9.55   MAIN                                                                  06/28/2021 10:42:03 PAGE 7   

 351   1        static uint16_t cnt_1ms = 0;
 352   1      
 353   1        const uint16_t div_5ms = 25;  
 354   1        static uint16_t cnt_5ms = 0;  
 355   1        
 356   1        const uint16_t div_10ms = 50;   //accurate 42 , with ADC conv.
 357   1        static uint16_t cnt_10ms = 0;
 358   1      
 359   1        set_flag(flag_200us,Enable);
 360   1      
 361   1        if (++cnt_1ms >= div_1ms) 
 362   1        {
 363   2          set_flag(flag_1ms,Enable);  
 364   2          cnt_1ms = 0;  
 365   2        }
 366   1        
 367   1        if (++cnt_5ms >= div_5ms) 
 368   1        {
 369   2          set_flag(flag_5ms,Enable);
 370   2          cnt_5ms = 0;  
 371   2        }
 372   1      
 373   1        if (++cnt_10ms >= div_10ms)
 374   1        {
 375   2          set_flag(flag_10ms,Enable);
 376   2          cnt_10ms = 0;   
 377   2        }
 378   1        
 379   1      }
 380          
 381          void Timer0_ISR(void) interrupt 1        // Vector @  0x0B
 382          {
 383   1          _push_(SFRS); 
 384   1        
 385   1          TH0 = u8TH0_Tmp;
 386   1          TL0 = u8TL0_Tmp;
 387   1          clr_TCON_TF0;
 388   1        
 389   1        Timer0_IRQHandler();
 390   1      
 391   1          _pop_(SFRS);  
 392   1      }
 393          
 394          void TIMER0_Init(void)
 395          {
 396   1        uint16_t res = 0;
 397   1      
 398   1        /*
 399   1          formula : 16bit 
 400   1          (0xFFFF+1 - target)  / (24MHz/psc) = time base 
 401   1      
 402   1        */  
 403   1        const uint16_t TIMER_DIVx_VALUE_200us_FOSC_240000 = 65536-400;
 404   1      
 405   1        ENABLE_TIMER0_MODE1;  // mode 0 : 13 bit , mode 1 : 16 bit
 406   1          TIMER0_FSYS_DIV12;
 407   1        
 408   1        u8TH0_Tmp = HIBYTE(TIMER_DIVx_VALUE_200us_FOSC_240000);
 409   1        u8TL0_Tmp = LOBYTE(TIMER_DIVx_VALUE_200us_FOSC_240000); 
 410   1      
 411   1          TH0 = u8TH0_Tmp;
 412   1          TL0 = u8TL0_Tmp;
C51 COMPILER V9.55   MAIN                                                                  06/28/2021 10:42:03 PAGE 8   

 413   1      
 414   1          ENABLE_TIMER0_INTERRUPT;                       //enable Timer0 interrupt
 415   1          ENABLE_GLOBAL_INTERRUPT;                       //enable interrupts
 416   1        
 417   1          set_TCON_TR0;                                  //Timer0 run
 418   1      }
 419          
 420          
 421          void Serial_ISR (void) interrupt 4 
 422          {
 423   1          _push_(SFRS);
 424   1      
 425   1          if (RI)
 426   1          {   
 427   2            uart0_receive_flag = 1;
 428   2            uart0_receive_data = SBUF;
 429   2            clr_SCON_RI;                                         // Clear RI (Receive Interrupt).
 430   2          }
 431   1          if  (TI)
 432   1          {
 433   2            if(!BIT_UART)
 434   2            {
 435   3                TI = 0;
 436   3            }
 437   2          }
 438   1      
 439   1          _pop_(SFRS);  
 440   1      }
 441          
 442          void UART0_Init(void)
 443          {
 444   1        #if 1
 445   1        const unsigned long u32Baudrate = 115200;
 446   1        P06_QUASI_MODE;    //Setting UART pin as Quasi mode for transmit
 447   1        
 448   1        SCON = 0x50;          //UART0 Mode1,REN=1,TI=1
 449   1        set_PCON_SMOD;        //UART0 Double Rate Enable
 450   1        T3CON &= 0xF8;        //T3PS2=0,T3PS1=0,T3PS0=0(Prescale=1)
 451   1        set_T3CON_BRCK;        //UART0 baud rate clock source = Timer3
 452   1      
 453   1        RH3    = HIBYTE(65536 - (SYS_CLOCK/16/u32Baudrate));  
 454   1        RL3    = LOBYTE(65536 - (SYS_CLOCK/16/u32Baudrate));  
 455   1        
 456   1        set_T3CON_TR3;         //Trigger Timer3
 457   1        set_IE_ES;
 458   1      
 459   1        ENABLE_GLOBAL_INTERRUPT;
 460   1      
 461   1        set_SCON_TI;
 462   1        BIT_UART=1;
 463   1        #else 
                  UART_Open(SYS_CLOCK,UART0_Timer3,115200);
                  ENABLE_UART0_PRINTF; 
                #endif
 467   1      }
 468          
 469          
 470          void MODIFY_HIRC_24(void)
 471          {
 472   1        unsigned char u8HIRCSEL = HIRC_24;
 473   1          unsigned char data hircmap0,hircmap1;
 474   1      //    unsigned int trimvalue16bit;
C51 COMPILER V9.55   MAIN                                                                  06/28/2021 10:42:03 PAGE 9   

 475   1          /* Check if power on reset, modify HIRC */
 476   1          SFRS = 0 ;
 477   1        #if 1
 478   1          IAPAL = 0x38;
 479   1        #else
                  switch (u8HIRCSEL)
                  {
                    case HIRC_24:
                      IAPAL = 0x38;
                    break;
                    case HIRC_16:
                      IAPAL = 0x30;
                    break;
                    case HIRC_166:
                      IAPAL = 0x30;
                    break;
                  }
                #endif
 493   1        
 494   1          set_CHPCON_IAPEN;
 495   1          IAPAH = 0x00;
 496   1          IAPCN = READ_UID;
 497   1          set_IAPTRG_IAPGO;
 498   1          hircmap0 = IAPFD;
 499   1          IAPAL++;
 500   1          set_IAPTRG_IAPGO;
 501   1          hircmap1 = IAPFD;
 502   1          clr_CHPCON_IAPEN;
 503   1      
 504   1        #if 0
                  switch (u8HIRCSEL)
                  {
                  case HIRC_166:
                  trimvalue16bit = ((hircmap0 << 1) + (hircmap1 & 0x01));
                  trimvalue16bit = trimvalue16bit - 15;
                  hircmap1 = trimvalue16bit & 0x01;
                  hircmap0 = trimvalue16bit >> 1;
              
                  break;
                  default: break;
                  }
                #endif
 517   1        
 518   1          TA = 0xAA;
 519   1          TA = 0x55;
 520   1          RCTRIM0 = hircmap0;
 521   1          TA = 0xAA;
 522   1          TA = 0x55;
 523   1          RCTRIM1 = hircmap1;
 524   1          clr_CHPCON_IAPEN;
 525   1          PCON &= CLR_BIT4;
 526   1      }
 527          
 528          
 529          void SYS_Init(void)
 530          {
 531   1          MODIFY_HIRC_24();
 532   1      
 533   1          ALL_GPIO_QUASI_MODE;
 534   1          ENABLE_GLOBAL_INTERRUPT;                // global enable bit  
 535   1      }
 536          
C51 COMPILER V9.55   MAIN                                                                  06/28/2021 10:42:03 PAGE 10  

 537          void main (void) 
 538          {
 539   1          SYS_Init();
 540   1      
 541   1          UART0_Init();
 542   1        GPIO_Init();          
 543   1      
 544   1        //TimerService  : 200us , 1ms , 5ms , 10ms
 545   1        TIMER0_Init();  // us base
 546   1      
 547   1        //(P1.2 , PWM0_CH0 , IC0) , input capture 
 548   1        CAP_Init();
 549   1          
 550   1          while(1)
 551   1          {
 552   2          task_loop();
 553   2          
 554   2          }
 555   1      }
 556          
 557          
 558          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2114    ----
   CONSTANT SIZE    =     67    ----
   XDATA SIZE       =     19      48
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
